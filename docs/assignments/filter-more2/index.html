<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.150.0">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Filter: More Comfortable &middot; AP CSP 2025-26</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://scienceacademy.github.io/web/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://scienceacademy.github.io/web/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://scienceacademy.github.io/web/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://scienceacademy.github.io/web/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class="theme-base-08 ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://scienceacademy.github.io/web/"><h1>AP CSP 2025-26</h1></a>
      <p class="lead">
       Mr. Bradfield&#39;s AP Computer Science Principles 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://scienceacademy.github.io/web/">Home</a> </li>
        <li><a href="https://code.cs50.io/"> CodeSpace IDE </a></li><li><a href="https://submit.cs50.io/"> View your submit50 submissions </a></li>
      </ul>
    </nav>

    <p>&copy; 2025. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Filter: More Comfortable</h1>
  <time datetime=2025-10-06T03:56:45-0700 class="post-date">Mon, Oct 6, 2025</time>
  <p>Implement a program that applies filters to images.</p>
<pre tabindex="0"><code>$ ./filter -g image.bmp grayscale.bmp
</code></pre><h2 id="background">Background</h2>
<h3 id="bitmaps">Bitmaps</h3>
<p>Perhaps the simplest way to represent an image is with a grid of pixels (i.e., dots), each of which can be of a different color. For black-and-white images, we thus need 1 bit per pixel, as 0 could represent black and 1 could represent white, as in the below.</p>
<p><img src="/web/bitmap.png" alt="alt"></p>
<p>In this sense, an image is just a bitmap (i.e., a map of bits). For more colorful images, you simply need more bits per pixel. A file format (like BMP, JPEG, or PNG) that supports “24-bit color” uses 24 bits per pixel. (BMP actually supports 1-, 4-, 8-, 16-, 24-, and 32-bit color.)</p>
<p>A 24-bit BMP uses 8 bits to signify the amount of red in a pixel’s color, 8 bits to signify the amount of green in a pixel’s color, and 8 bits to signify the amount of blue in a pixel’s color. If you’ve ever heard of RGB color, well, there you have it: red, green, blue.</p>
<p>If the R, G, and B values of some pixel in a BMP are, say, <code>0xff</code>, <code>0x00</code>, and <code>0x00</code> in hexadecimal, that pixel is purely red, as <code>0xff</code> (otherwise known as <code>255</code> in decimal) implies “a lot of red,” while <code>0x00</code> and <code>0x00</code> imply “no green” and “no blue,” respectively.</p>
<h3 id="a-bitmap-more-technical">A Bit(map) More Technical</h3>
<p>Recall that a file is just a sequence of bits, arranged in some fashion. A 24-bit BMP file, then, is essentially just a sequence of bits, (almost) every 24 of which happen to represent some pixel’s color. But a BMP file also contains some “metadata,” information like an image’s height and width. That metadata is stored at the beginning of the file in the form of two data structures generally referred to as “headers,” not to be confused with C’s header files. (Incidentally, these headers have evolved over time. This problem uses the latest version of Microsoft’s BMP format, 4.0, which debuted with Windows 95.)</p>
<p>The first of these headers, called <code>BITMAPFILEHEADER</code>, is 14 bytes long. (Recall that 1 byte equals 8 bits.) The second of these headers, called <code>BITMAPINFOHEADER</code>, is 40 bytes long. Immediately following these headers is the actual bitmap: an array of bytes, triples of which represent a pixel’s color. However, BMP stores these triples backwards (i.e., as BGR), with 8 bits for blue, followed by 8 bits for green, followed by 8 bits for red. (Some BMPs also store the entire bitmap backwards, with an image’s top row at the end of the BMP file. But this problem set’s BMPs are stored with each bitmap’s top row first and bottom row last.) In other words, were we to convert the 1-bit smiley above to a 24-bit smiley, substituting red for black, a 24-bit BMP would store this bitmap as follows, where <code>0000ff</code> signifies red and <code>ffffff</code> signifies white; we’ve highlighted in red all instances of <code>0000ff</code>.</p>
<p><img src="/web/red_smile.png" alt="alt"></p>
<p>Because we’ve presented these bits from left to right, top to bottom, in 8 columns, you can actually see the red smiley if you take a step back.</p>
<p>To be clear, recall that a hexadecimal digit represents 4 bits. Accordingly, <code>ffffff</code> in hexadecimal actually signifies <code>111111111111111111111111</code> in binary.</p>
<p>Notice that you could represent a bitmap as a 2-dimensional array of pixels: where the image is an array of rows, each row is an array of pixels. Indeed, that’s how we’ve chosen to represent bitmap images in this problem.</p>
<h2 id="image-filtering">Image Filtering</h2>
<p>What does it even mean to filter an image? You can think of filtering an image as taking the pixels of some original image, and modifying each pixel in such a way that a particular effect is apparent in the resulting image.</p>
<h3 id="pixelate">Pixelate</h3>
<p>The pixelate filter creates a mosaic effect by dividing the image into square blocks and replacing all pixels within each block with the average color of that block. This effect is commonly seen in images where faces or sensitive information needs to be obscured.</p>
<p>To implement the pixelate filter, you&rsquo;ll need to:</p>
<ol>
<li>Divide the image into blocks of a fixed size (use a block size of 10×10 pixels)</li>
<li>For each block, calculate the average red, green, and blue values of all pixels within that block</li>
<li>Replace every pixel in the block with this averaged color</li>
</ol>
<p><strong>Important considerations:</strong></p>
<ul>
<li>Images may not divide evenly by the block size. When you reach the right or bottom edge of the image, you may have partial blocks (for example, if the image width is 47 pixels and your block size is 10, the rightmost blocks will only be 7 pixels wide). Handle these partial blocks by calculating the average over only the pixels that actually exist.</li>
<li>Remember to round your averages to the nearest integer when assigning them back to pixel values.</li>
<li>You&rsquo;ll need to calculate and store the average for each block before applying it to avoid using already-modified pixel values in your calculations.</li>
</ul>
<p><strong>Example:</strong> If you have a 3×3 image where all pixels have different colors, and your block size is 10 (larger than the image), the entire image becomes one block. All nine pixels would be replaced with the average color of those nine pixels, creating a solid-colored 3×3 image.</p>
<h3 id="vignette">Vignette</h3>
<p>The vignette filter creates a vintage photograph effect by gradually darkening the edges and corners of an image while keeping the center bright. This draws the viewer&rsquo;s eye toward the center of the image.</p>
<p>To implement the vignette filter, you&rsquo;ll need to:</p>
<ol>
<li>Calculate the center point of the image</li>
<li>For each pixel, calculate its distance from the center</li>
<li>Use this distance to determine how much to darken the pixel (pixels farther from center should be darker)</li>
<li>Apply the darkening by multiplying each color channel by a darkening factor</li>
</ol>
<p><strong>The mathematical approach:</strong></p>
<ul>
<li>Calculate the distance from a pixel at position <code>(row, col)</code> to the center using the distance formula: <code>distance = √((col - center_x)² + (row - center_y)²)</code></li>
<li>Normalize this distance by dividing by the maximum possible distance (the distance from the center to a corner): <code>max_distance = √(center_x² + center_y²)</code></li>
<li>Calculate the darkening factor using a quadratic falloff: <code>factor = 1.0 - (normalized_distance² × VIGNETTE_STRENGTH)</code>, where <code>VIGNETTE_STRENGTH = 1.2</code></li>
<li>Ensure the factor doesn&rsquo;t go below 0 (clamp negative values to 0)</li>
<li>Multiply each color channel (red, green, blue) by this factor and round to the nearest integer</li>
</ul>
<p><strong>Important considerations:</strong></p>
<ul>
<li>Pixels at the center (distance = 0.0) will have a factor close to 1.0, meaning they stay bright</li>
<li>Pixels at the corners (distance = max_distance) will have a factor close to or equal to 0.0, meaning they become very dark or black</li>
<li>Don&rsquo;t forget to use floating-point arithmetic for your calculations, but convert back to integers when assigning to pixel values</li>
<li>The <code>math.h</code> library provides <code>sqrt()</code> for square root calculations</li>
</ul>
<p><strong>Example:</strong> In a 3×3 image, the center pixel should remain relatively unchanged, edge pixels should be moderately darkened, and corner pixels should become very dark or completely black, creating a smooth gradient from bright center to dark edges.</p>
<h3 id="edges">Edges</h3>
<p>In artificial intelligence algorithms for image processing, it is often useful to detect edges in an image: lines in the image that create a boundary between one object and another. One way to achieve this effect is by applying the <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel operator</a>to the image.</p>
<p>Like image blurring, edge detection also works by taking each pixel, and modifying it based on the 3x3 grid of pixels that surrounds that pixel. But instead of just taking the average of the nine pixels, the Sobel operator computes the new value of each pixel by taking a weighted sum of the values for the surrounding pixels. And since edges between objects could take place in both a vertical and a horizontal direction, you’ll actually compute two weighted sums: one for detecting edges in the x direction, and one for detecting edges in the y direction. In particular, you’ll use the following two “kernels”:</p>
<p><img src="/web/sobel.png" alt="alt"></p>
<p>How to interpret these kernels? In short, for each of the three color values for each pixel, we’ll compute two values <code>Gx</code> and <code>Gy</code>. To compute <code>Gx</code> for the red channel value of a pixel, for instance, we’ll take the original red values for the nine pixels that form a 3x3 box around the pixel, multiply them each by the corresponding value in the Gx kernel, and take the sum of the resulting values.</p>
<p>Why these particular values for the kernel? In the <code>Gx</code> direction, for instance, we’re multiplying the pixels to the right of the target pixel by a positive number, and multiplying the pixels to the left of the target pixel by a negative number. When we take the sum, if the pixels on the right are a similar color to the pixels on the left, the result will be close to 0 (the numbers cancel out). But if the pixels on the right are very different from the pixels on the left, then the resulting value will be very positive or very negative, indicating a change in color that likely is the result of a boundary between objects. And a similar argument holds true for calculating edges in the <code>y</code> direction.</p>
<p>Using these kernels, we can generate a <code>Gx</code> and <code>Gy</code> value for each of the red, green, and blue channels for a pixel. But each channel can only take on one value, not two: so we need some way to combine <code>Gx</code> and <code>Gy</code> into a single value. The Sobel filter algorithm combines <code>Gx</code> and <code>Gy</code> into a final value by calculating the square root of <code>Gx^2 + Gy^2</code>. And since channel values can only take on integer values from 0 to 255, be sure the resulting value is rounded to the nearest integer and capped at 255!</p>
<p>And what about handling pixels at the edge, or in the corner of the image? There are many ways to handle pixels at the edge, but for the purposes of this problem, we’ll ask you to treat the image as if there was a 1 pixel solid black border around the edge of the image: therefore, trying to access a pixel past the edge of the image should be treated as a solid black pixel (values of 0 for each of red, green, and blue). This will effectively ignore those pixels from our calculations of <code>Gx</code> and <code>Gy</code>.</p>
<h2 id="getting-started">Getting Started</h2>
<p>Here’s how to download this problem’s “distribution code” (i.e., starter code). Log into your Codespace and then, in a terminal window, execute each of the below.</p>
<ul>
<li>Execute <code>cd</code> to ensure you&rsquo;re in <code>~/</code> (i.e. your home directory).</li>
<li>Execute the following to download a (compressed) ZIP file with this assignment’s distribution:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-md" data-lang="md"><span style="display:flex;"><span>wget https://scienceacademy.github.io/web/filter-more.zip
</span></span></code></pre></div><ul>
<li>Execute <code>unzip filter-more.zip</code> to uncompress that file.</li>
<li>You&rsquo;ll now see a <code>filter-more</code> directory in your file list.</li>
<li>It contains the following files: <code>bmp.h</code>, <code>filter.c</code>, <code>helpers.h</code>, <code>helpers.c</code>, and <code>Makefile</code>. You&rsquo;ll also see a directory called <code>images</code> with some sample bitmaps.</li>
</ul>
<h2 id="understanding">Understanding</h2>
<p>Now let&rsquo;s take a look at some of the files provided to you as distribution code to get an understanding for what’s inside of them.</p>
<ul>
<li><code>bmp.h</code></li>
</ul>
<p>Open up <code>bmp.h</code> (by double-clicking on it in the file browser) and have a look.</p>
<p>You’ll see definitions of the headers we’ve mentioned (<code>BITMAPINFOHEADER</code> and <code>BITMAPFILEHEADER</code>). In addition, that file defines <code>BYTE</code>, <code>DWORD</code>, <code>LONG</code>, and <code>WORD</code>, data types normally found in the world of Windows programming. Notice how they’re just aliases for primitives with which you are (hopefully) already familiar. It appears that <code>BITMAPFILEHEADER</code> and <code>BITMAPINFOHEADER</code> make use of these types.</p>
<p>Most importantly for you, this file also defines a struct called <code>RGBTRIPLE</code> that, quite simply, “encapsulates” three bytes: one blue, one green, and one red (the order, recall, in which we expect to find RGB triples actually on disk).</p>
<p>Why are these <code>struct</code>s useful? Well, recall that a file is just a sequence of bytes (or, ultimately, bits) on disk. But those bytes are generally ordered in such a way that the first few represent something, the next few represent something else, and so on. “File formats” exist because the world has standardized what bytes mean what. Now, we could just read a file from disk into RAM as one big array of bytes. And we could just remember that the byte at <code>array[i]</code> represents one thing, while the byte at <code>array[j]</code> represents another. But why not give some of those bytes names so that we can retrieve them from memory more easily? That’s precisely what the structs in <code>bmp.h</code> allow us to do. Rather than think of some file as one long sequence of bytes, we can instead think of it as a sequence of <code>struct</code>s.</p>
<ul>
<li><code>filter.c</code></li>
</ul>
<p>Now, open up <code>filter.c</code>. This file has been written already for you, but there are a couple important points worth noting here.</p>
<p>First, notice the definition of <code>filters</code> on line 11. That string tells the program what the allowable command-line arguments to the program are: <code>b</code>, <code>g</code>, <code>r</code>, and <code>s</code>. Each of them specifies a different filter that we might apply to our images: blur, grayscale, reflection, and sepia.</p>
<p>The next several lines open up an image file, make sure it’s indeed a BMP file, and read all of the pixel information into a 2D array called <code>image</code>.</p>
<p>Scroll down to the <code>switch</code> statement that begins on line 102. Notice that, depending on what <code>filter</code> we’ve chosen, a different function is called: if the user chooses filter <code>b</code>, the program calls the <code>blur</code> function; if <code>g</code>, then <code>grayscale </code>is called; if <code>r</code>, then <code>reflect</code> is called; and if <code>s</code>, then <code>sepia</code> is called. Notice, too, that each of these functions take as arguments the <code>height</code> of the image, the <code>width</code> of the image, and the 2D array of pixels.</p>
<p>These are the functions you’ll implement. As you might imagine, the goal is for each of these functions to edit the 2D array of pixels in such a way that the desired filter is applied to the image.</p>
<p>The remaining lines of the program take the resulting <code>image</code> and write them out to a new image file.</p>
<ul>
<li><code>helpers.h</code></li>
</ul>
<p>Next, take a look at <code>helpers.h</code>. This file is quite short, and just provides the function prototypes for the functions named earlier.</p>
<p>Take note of the fact that each function takes a 2D array called <code>image</code> as an argument, where <code>image</code> is an array of <code>height</code> many rows, and each row is itself another array of <code>width</code> many <code>RGBTRIPLE</code>s. So if <code>image</code> represents the whole picture, then <code>image[0]</code> represents the first row, and <code>image[0][0]</code> represents the pixel in the upper-left corner of the image.</p>
<ul>
<li><code>helpers.c</code></li>
</ul>
<p>Finally, open <code>helpers.c</code>. Here’s where the implementation of the functions declared in <code>helpers.h</code> belong. Right now, the implementations are missing! This part is up to you.</p>
<h3 id="makefile">Makefile</h3>
<p>There&rsquo;s also a <code>Makefile</code>, which specifies what happens when you run <code>make filter</code>. In the past, we&rsquo;ve written programs that were confined to just one file, but this project contains multiple: <code>filter.c</code>, &lsquo;helpers.h<code>, and </code>helpers.c<code>. </code>Makefile` tells the compiler how to include those files.</p>
<p>Try compiling <code>filter</code> by running</p>
<pre tabindex="0"><code>$ make filter
</code></pre><p>Then you can run the program with</p>
<pre tabindex="0"><code>$ ./filter -g images/yard.bmp out.bmp
</code></pre><p>This generates a new image called <code>out.bmp</code> after calling the <code>grayscale</code> function. <code>grayscale</code> doesn&rsquo;t do anything yet, though, so the output image just matches the original.</p>
<h2 id="specification">Specification</h2>
<p>Implement the functions in <code>helpers.c</code>.</p>
<ul>
<li>The function <code>grayscale</code> should take an image and turn it into a black-and-white version of the same image.</li>
<li>The <code>reflect</code> function should take an image and reflect it horizontally.</li>
<li>The <code>blur</code> function should take an image and turn it into a box-blurred version of the same image.</li>
<li>The <code>edges</code> function should take an image and highlight the edges between objects, using the Sobel operator.</li>
</ul>
<p>You should not modify any of the function signatures, nor should you modify any other files other than <code>helpers.c</code>.</p>
<h2 id="hints">Hints</h2>
<ul>
<li>The values of a pixel’s <code>rgbtRed</code>, <code>rgbtGreen</code>, and <code>rgbtBlue</code> components are all integers, so be sure to round any floating-point numbers to the nearest integer when assigning them to a pixel value!</li>
</ul>
<h2 id="testing">Testing</h2>
<p>Be sure to test all of your filters on the example bitmaps!</p>
<p>Execute the below to evaluate the correctness of your code using check50. But be sure to compile and test it yourself as well!</p>
<pre tabindex="0"><code>check50 scienceacademy/problems/2025ap/filter/more
</code></pre><h2 id="how-to-submit">How to Submit</h2>
<p>Execute the below to submit your code:</p>
<pre tabindex="0"><code>submit50 scienceacademy/problems/2025ap/filter/more
</code></pre>
</div>
    </main>

    
  </body>
</html>
